from typing import List, Dict, Any, Optional
import logging
from src.models.balance import Balance
from src.client import ocs_client

logger = logging.getLogger(__name__)

async def create_balance(subscriptionId: str, balance: Balance) -> Dict[str, Any]:
    """
**Tool Name:** Create Balance

**Purpose:** Creates a balance instance for a specific subscription. Balances represent service allowances (voice SECONDS, SMS/MMS EVENTS, data BYTES) that subscribers can consume. This tool is typically used after creating a subscription to provision the service allowances defined in the offer.

**Parameters:**
- `subscriptionId` (required): The unique identifier of the subscription to which this balance will be attached
- `balance` (required): Balance object with all required fields populated

**How to Obtain subscriptionId:**
The subscription ID is available from:
1. **From create_subscription response**: When creating a new subscription, the response includes the `subscriptionId`
2. **From get_subscriber response**: The response includes a `subscriptions` array where each subscription contains a `subscriptionId` field
3. **From list_subscriptions response**: Each subscription in the list includes its `subscriptionId`

**Balance Object Fields:**
- `balanceId` (optional/generated): Unique identifier for the balance, typically auto-generated by the system
- `balanceType`: Type of balance (e.g., "ALLOWANCE" for prepaid/postpaid allowances)
- `unitType`: Unit of measurement - must be one of:
  - `"SECONDS"`: For voice services (e.g., 3600 = 1 hour of calls)
  - `"EVENTS"`: For SMS/MMS services (e.g., 1000 = 1000 messages)
  - `"BYTES"`: For data services (e.g., 10737418240 = 10GB)
- `balanceAmount`: Initial/total balance amount in the specified units
- `balanceAvailable`: Currently available balance (initially same as balanceAmount)
- `effectiveDate`: When the balance becomes active (timestamp)
- `expirationDate`: When the balance expires (timestamp)
- `isRecurring`: Whether balance renews automatically (true/false)
- `cycleLengthType`: Renewal cycle unit ("MONTH", "WEEK", "DAY")
- `cycleLengthUnits`: Renewal cycle length (e.g., 1 for monthly, 4 for 4 weeks)
- `maxRecurringCycles`: Maximum number of renewal cycles (null for unlimited)
- `isRolloverAllowed`: Whether unused balance rolls over to next cycle (true/false)
- `maxRolloverAmount`: Maximum amount that can roll over (0 if rollover not allowed)
- `isGroupBalance`: Whether this is a shared balance for group subscriptions (typically false)

**Typical Workflow:**
1. Create a subscription using `create_subscription`
2. Extract the `subscriptionId` from the response
3. For each balance defined in the offer (voice, SMS, data):
   a. Map offer balance definition to Balance object
   b. Call `create_balance(subscriptionId, balance)`
   c. Verify balance creation was successful
4. Optionally activate the subscription using `change_subscription_state` if not already active

**Returns:**
- Success (201): Complete balance object including:
  - `balanceId`: Generated unique identifier for the balance
  - `subscriptionId`: Associated subscription ID
  - All balance configuration fields
  - Creation and lifecycle timestamps
- Error (404): Subscription not found
- Error (409): Conflict - duplicate balance (e.g., balance with same type and unit already exists for this subscription)
- Error (400): Bad request - invalid balance data (e.g., negative amounts, invalid unit type)

**Use Cases:**
- Provisioning service allowances when creating a new subscription from an offer
- Adding additional data bundles to existing subscriptions (e.g., one-time 5GB data boost)
- Creating promotional balances or bonus allowances
- Setting up group shared balances for family plans
- Migrating balances when upgrading/downgrading subscription plans

**Important Considerations:**
- **Balance Units**: Always use the correct unit type:
  - Voice: SECONDS (3600 = 1 hour)
  - SMS/MMS: EVENTS (1 event = 1 message)
  - Data: BYTES (1073741824 = 1GB, 10737418240 = 10GB)
- **Recurring Balances**: Set `isRecurring=true` for monthly/weekly allowances that renew automatically
- **Rollover**: Configure rollover settings carefully - rollover allows unused balance to carry forward to next cycle
- **Expiration**: Set appropriate expiration dates - typically aligned with subscription cycle end dates
- **Multiple Balances**: A subscription can have multiple balances (one for voice, one for SMS, one for data)
- **Balance Conflicts**: Cannot create duplicate balances with same type and unit for a subscription

**Example - Creating Voice Balance:**
```
Offer balance definition:
{
  "type": "ALLOWANCE",
  "amount": 3600,
  "unit": "SECONDS",
  "recurring": true,
  "cycleLength": 1,
  "cycleUnit": "MONTH",
  "rolloverAllowed": false,
  "maxRolloverAmount": 0,
  "description": "1 hour voice allowance"
}

Maps to Balance object:
{
  "balanceType": "ALLOWANCE",
  "unitType": "SECONDS",
  "balanceAmount": 3600,
  "balanceAvailable": 3600,
  "isRecurring": true,
  "cycleLengthType": "MONTH",
  "cycleLengthUnits": 1,
  "isRolloverAllowed": false,
  "maxRolloverAmount": 0,
  "effectiveDate": "2025-12-23T00:00:00Z",
  "expirationDate": "2026-01-23T00:00:00Z"
}
```

**Integration with Offers:**
When creating balances from an offer's balance definitions, use the `create_subscription_and_balances_from_offer` guidance to ensure proper field mapping and values and balance provisioning workflow.
    """
    data = balance.model_dump(mode='json', exclude_none=True)
    logger.info(f"create_balance called for subscription {subscriptionId} with data: {data}")
    result = await ocs_client.request(
        method="POST",
        endpoint=f"/subscriptions/{subscriptionId}/balances",
        json=data
    )
    logger.info(f"create_balance result: {result}")
    return result

async def list_balances(subscriptionId: str) -> List[Dict[str, Any]]:
    """
**Tool Name:** List Balances

**Purpose:** Retrieves all balance instances associated with a specific subscription. This provides a complete view of all service allowances (voice, SMS, data) available to the subscriber, including current amounts, usage, and expiration details.

**Parameters:**
- `subscriptionId` (required): The unique identifier of the subscription whose balances to retrieve

**How to Obtain subscriptionId:**
The subscription ID is available from:
1. **From get_subscriber response**: When calling `get_subscriber(subscriberId)`, the response includes a `subscriptions` array where each subscription contains a `subscriptionId` field
2. **From list_subscriptions response**: When calling `list_subscriptions(subscriberId)`, each subscription includes its `subscriptionId`
3. **From create_subscription response**: When creating a new subscription, the response includes the generated `subscriptionId`

**Typical Workflow:**
1. Call `get_subscriber(subscriberId)` or `list_subscriptions(subscriberId)` to retrieve subscriptions
2. Extract `subscriptionId` from the desired subscription
3. Call `list_balances(subscriptionId)` to retrieve all balances for that subscription
4. Review balance details including amounts, units, expiration dates, and rollover settings

**Returns:**
- Success (200): Array of balance objects, where each balance includes:
  - `balanceId`: Unique identifier for the balance
  - `subscriptionId`: Associated subscription ID
  - `balanceType`: Type of balance (e.g., "ALLOWANCE")
  - `unitType`: Unit of measurement ("SECONDS", "EVENTS", "BYTES")
  - `balanceAmount`: Total/initial balance amount
  - `balanceAvailable`: Currently available balance (after usage)
  - `effectiveDate`: When balance became active
  - `expirationDate`: When balance expires
  - `isRecurring`: Whether balance renews automatically
  - `cycleLengthType` & `cycleLengthUnits`: Renewal cycle information
  - `isRolloverAllowed`: Whether unused balance rolls over
  - `maxRolloverAmount`: Maximum rollover amount
  - `rolloverAmount`: Current rollover amount from previous cycle
  - `recurringCyclesCompleted`: Number of renewal cycles completed
  - Lifecycle timestamps: `creationDate`, `lastModifiedDate`
- Success (200) with empty array: Subscription has no balances provisioned yet
- Error (404): Subscription not found

**Use Cases:**
- Checking subscriber's available service allowances (voice minutes, SMS count, data quota)
- Displaying usage dashboard to subscribers or support agents
- Verifying balances were provisioned correctly after subscription creation
- Monitoring balance consumption and determining when to add more allowances
- Auditing balance configuration (renewal settings, rollover rules, expiration dates)
- Troubleshooting service availability issues

**Balance Interpretation:**
- **Voice Balances** (unitType: "SECONDS"):
  - `balanceAvailable`: Remaining call time in seconds (e.g., 3600 = 1 hour)
  - Usage: `balanceAmount - balanceAvailable` = consumed call time
  
- **SMS/MMS Balances** (unitType: "EVENTS"):
  - `balanceAvailable`: Remaining message count (e.g., 1000 messages)
  - Usage: `balanceAmount - balanceAvailable` = messages sent
  
- **Data Balances** (unitType: "BYTES"):
  - `balanceAvailable`: Remaining data quota in bytes (e.g., 10737418240 = 10GB)
  - Usage: `balanceAmount - balanceAvailable` = data consumed
  - Conversion: 1GB = 1073741824 bytes, 10GB = 10737418240 bytes

**When to Use:**
- Use `list_balances` when you need to see all balances for a subscription at once
- Use after `create_subscription` to verify balances were provisioned correctly
- Use regularly to monitor subscriber service allowances and usage
- Use before recommending upgrades/add-ons based on usage patterns

**Example:**
```
Call: list_balances("SUB-12345")
Response: [
  {
    "balanceId": "BAL-001",
    "balanceType": "ALLOWANCE",
    "unitType": "SECONDS",
    "balanceAmount": 3600,
    "balanceAvailable": 2100,
    "expirationDate": "2026-01-23T00:00:00Z",
    "isRecurring": true,
    ...
  },
  {
    "balanceId": "BAL-002",
    "balanceType": "ALLOWANCE",
    "unitType": "EVENTS",
    "balanceAmount": 1000,
    "balanceAvailable": 750,
    "expirationDate": "2026-01-23T00:00:00Z",
    "isRecurring": true,
    ...
  },
  {
    "balanceId": "BAL-003",
    "balanceType": "ALLOWANCE",
    "unitType": "BYTES",
    "balanceAmount": 10737418240,
    "balanceAvailable": 5368709120,
    "expirationDate": "2026-01-23T00:00:00Z",
    "isRecurring": true,
    ...
  }
]

Interpretation:
- Voice: 2100 seconds (35 minutes) remaining of 3600 seconds (1 hour) - 42% consumed
- SMS: 750 messages remaining of 1000 - 25% consumed
- Data: 5GB remaining of 10GB - 50% consumed
```

**Best Practices:**
- Check balances after subscription creation to verify proper provisioning
- Monitor balances regularly to identify low-balance situations
- Use balance information to recommend appropriate offers or add-ons
- Consider rollover amounts when evaluating actual available balances
- Check expiration dates to warn users of upcoming balance expiry
    """
    logger.info(f"list_balances called for subscription {subscriptionId}")
    result = await ocs_client.request(
        method="GET",
        endpoint=f"/subscriptions/{subscriptionId}/balances"
    )
    logger.info(f"list_balances result: {result}")
    return result

async def delete_balances(subscriptionId: str) -> Optional[Dict[str, Any]]:
    """
**Tool Name:** Delete Balances

**Purpose:** Permanently removes all balance instances associated with a specific subscription. This terminates all service allowances (voice, SMS, data) for the subscription. Use with extreme caution as this action cannot be undone.

**Parameters:**
- `subscriptionId` (required): The unique identifier of the subscription whose balances to delete

**How to Obtain subscriptionId:**
The subscription ID is available from:
1. **From get_subscriber response**: When calling `get_subscriber(subscriberId)`, the response includes a `subscriptions` array where each subscription contains a `subscriptionId` field
2. **From list_subscriptions response**: When calling `list_subscriptions(subscriberId)`, each subscription includes its `subscriptionId`
3. **From get_subscription response**: If you already retrieved subscription details

**Typical Workflow:**
1. Call `get_subscription(subscriptionId)` to verify subscription exists and check its state
2. Call `list_balances(subscriptionId)` to review what balances will be deleted
3. Confirm with user that all balances should be permanently removed
4. Call `delete_balances(subscriptionId)` to remove all balances
5. Optionally provision new balances if this is part of a plan change/upgrade

**Important Considerations:**
- **Permanent Action**: Deletion is irreversible - all balance data will be permanently lost
- **Service Termination**: Deleting balances immediately terminates all service allowances:
  - No voice calls can be made
  - No SMS/MMS messages can be sent
  - No data services will be available
- **Multiple Balances**: This operation deletes ALL balances for the subscription (voice, SMS, and data)
- **No Refund**: Any unused balance amounts are forfeited - subscriber loses remaining allowances
- **Subscription Impact**: The subscription remains active but has no service allowances
- **Alternative Actions**: 
  - Consider using `change_subscription_state` with "suspend" to temporarily disable service
  - Consider creating new balances instead if upgrading/changing plans

**When to Use:**
- **Plan Migration**: Removing old balances before provisioning new ones during plan upgrade/downgrade
- **Subscription Cancellation**: As part of subscription termination workflow before calling `delete_subscription`
- **Error Correction**: Cleaning up incorrectly provisioned balances
- **Service Reconfiguration**: Completely resetting balance configuration for a subscription
- **Testing/Development**: Cleaning up test data

**When NOT to Use:**
- **Temporary Service Suspension**: Use `change_subscription_state` with "suspend" instead
- **Balance Adjustment**: Cannot delete individual balances - this deletes ALL balances
- **Before Subscription Deletion**: If deleting the subscription, balances are automatically removed

**Returns:**
- Success (204): All balances successfully deleted, no content returned
- Success (200): Some systems may return confirmation with deletion summary
- Error (404): Subscription not found
- Error (409): Conflict - balances cannot be deleted due to pending transactions or business rules

**Use Cases:**
- Removing all existing balances before provisioning new ones during plan change
- Cleaning up balances when cancelling subscription (before calling delete_subscription)
- Correcting balance provisioning errors (delete all, then recreate correctly)
- Migrating subscription to different offer (remove old balances, add new ones)
- Resetting subscriber service allowances for testing purposes

**Example Workflow - Plan Upgrade:**
```
Step 1: Check current subscription and balances
  → Call get_subscription("SUB-12345")
  → Call list_balances("SUB-12345")
  → Current balances: Voice 3600 SECONDS, SMS 1000 EVENTS, Data 10GB

Step 2: Delete existing balances
  → Call delete_balances("SUB-12345")
  → All balances removed

Step 3: Create new balances from new offer
  → Get offer details: get_offer_by_id("1010")
  → Create voice balance: create_balance("SUB-12345", voiceBalance)
  → Create SMS balance: create_balance("SUB-12345", smsBalance)
  → Create data balance: create_balance("SUB-12345", dataBalance)

Step 4: Verify new balances
  → Call list_balances("SUB-12345")
  → Confirm new allowances provisioned correctly
```

**Best Practices:**
- Always retrieve and review balances before deletion
- Confirm deletion action with user, especially for active subscriptions with remaining allowances
- Document the reason for balance deletion in logs/audit trail
- Provision new balances immediately after deletion to restore service (if applicable)
- Verify subscription state before deleting balances
- Consider the financial impact - unused balance amounts are forfeited
- Use as part of a larger workflow (plan change, cancellation) rather than standalone
- For individual balance removal, consider balance expiration dates instead of deletion

**Security Note:**
This operation immediately impacts service availability. Ensure proper authorization and user confirmation before executing, especially for production subscriber accounts with active services.
    """
    logger.info(f"delete_balances called for subscription {subscriptionId}")
    result = await ocs_client.request(
        method="DELETE",
        endpoint=f"/subscriptions/{subscriptionId}/balances"
    )
    logger.info(f"delete_balances result: {result}")
    return result
